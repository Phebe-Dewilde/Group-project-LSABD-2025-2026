---
title: "01_Preprocessing methylomics project"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(stringr)
```

1. Data loading

In this section we load the original methylomics dataset.
We keep the raw data untouched and create a separate object for all preprocessing steps.
```{r}
raw_data <- read_csv("colon_stomach_lung_cancer_loyfer_zhang_weightedmean_and_metadata.csv")
dim(raw_data)
head(raw_data[, 1:8])
```
2. Metadata cleaning

We first cleaned the metadata before focusing on the CpG loci.
The main steps were:

2.1 removing the non-informative column label_organism (always homo sapiens) as this did not matter for further analysis.

2.2 recoding gender to a binary variable (M = 0, F = 1)

2.3 creating a new variable label_disease (Healthy vs Disease)-> the first 38 samples are considered 'healthy', the rest disease.

2.4 harmonising the tissue and source labels 

2.5 assigning a clinical stage and site label to healthy samples
```{r}
data_clean <- raw_data %>%

# drop non-informative organism column

select(-label_organism) %>%

# recode gender to binary

mutate(
label_gender = recode(
label_gender,
"M" = 0,
"F" = 1,
.default = NA_real_
)
) %>%

# create new column: label_disease. First 38 samples are considered healthy, the rest are disease

mutate(
label_disease = if_else(row_number() <= 38, "Healthy", "Disease")
) %>%
relocate(label_disease, .before = 6) %>%

# standardise tissue and source labels

mutate(
label_tissue = label_tissue |>
str_squish() |>
str_to_lower() |>
str_replace_all(" ", "_"),
label_source_of_sample = label_source_of_sample |>
str_squish() |>
str_to_lower() |>
str_replace_all(" ", "_")
) %>%
mutate(
label_source_of_sample = case_when(
label_source_of_sample %in% c("lymph_node", "lymphnode", "lymph_nodes") ~ "lymph_node",
TRUE ~ label_source_of_sample
)
) %>%

# assign stage 0 and 'Healthy' site label for healthy samples

mutate(
`label_clinical stage` = if_else(
label_disease == "Healthy",
"0",
`label_clinical stage`
),
`label_site label` = if_else(
label_disease == "Healthy",
"Healthy",
`label_site label`
)
)
#check
dim(data_clean)

```

3. Linking CpG loci to promoter annotation

We were provided with a BED file containing genomic positions.
To link our gene promotor to genese, we used the genomic coordinates to map each CpG locus to a promoter name.

The CpG column names in our dataset have the pattern:

chrom_chromStart_chromEnd (e.g. chr1_958245_961305)

The BED file has separate chrom, chromStart and chromEnd columns,
so we constructed the same key and used it to rename the CpG columns.

```{r}
enhancers <- read.table("promoter_hg38_extended.bed",
header = FALSE,
sep = "\t",
stringsAsFactors = FALSE
)

# First row contains the header

colnames(enhancers) <- enhancers[1, ]
enhancers <- enhancers[-1, ]

# Unique key: chrom_chromStart_chromEnd to match our CpG loci columns

enhancers$key <- paste(
enhancers$chrom,
enhancers$chromStart,
enhancers$chromEnd,
sep = "_"
)

# Map from genomic key to promoter name

name_map <- setNames(enhancers$name, enhancers$key)

old_names <- colnames(data_clean)

new_names <- ifelse(
old_names %in% names(name_map),
name_map[old_names],
old_names
)

colnames(data_clean) <- new_names

# Check that no genomic coordinates remain -> must be zero= mapping worked:
sum(str_detect(colnames(data_clean), "^chr"))
```
4. Defining metadata vs CpG loci

We separated metadata columns from CpG loci, because all downstream filtering
(missingness and variance) is only applied to the CpG part of the dataset.
```{r}
meta_cols <- c(
"label_title",
"label_gender",
"label_age",
"label_tissue",
"label_source_of_sample",
"label_disease",
"label_clinical stage",
"label_site label"
)

meta_cols <- intersect(meta_cols, names(data_clean))
gene_cols <- setdiff(names(data_clean), meta_cols)

data_genes <- data_clean[, gene_cols]
```
5. Missingness analysis and cutoff choice

We first visualised the proportion of missing values per CpG locus.Two visualisations were made
Based on the distribution, we decided to keep loci with at most 25% missingness.
```{r}
missing_summary <- data_genes %>%
summarise(across(everything(), ~ sum(is.na(.)))) %>%
pivot_longer(
everything(),
names_to = "CpG_locus",
values_to = "missing_values"
) %>%
mutate(
missing_percentage = (missing_values / nrow(data_clean)) * 100
) %>%
arrange(desc(missing_percentage))
```

```{r}
# Barplot (axis text hidden due to large number of loci)

missing_summary %>%
ggplot(aes(x = reorder(CpG_locus, missing_percentage),
y = missing_percentage)) +
geom_col(fill="steelblue")+
coord_flip() +
labs(
title = "Percentage of missing values by CpG locus",
x = "CpG locus",
y = "% of missing values"
) +
theme_minimal() +
theme(axis.text.y = element_blank())
```

```{r}
# Histogram of missingness distribution

ggplot(missing_summary, aes(x = missing_percentage)) +
geom_histogram(bins = 40) +
theme_minimal() +
labs(
title = "Distribution of missingness across CpG loci",
x = "% of missing values",
y = "Number of loci"
)
```
6. Filter CpG loci with >25% missingness
We then applied a cutoff of 25%: loci with more than 25% missing values were removed.
```{r}
miss_cutoff <- 0.25

na_fraction <- colMeans(is.na(data_genes))
genes_keep_missing <- names(na_fraction)[na_fraction <= miss_cutoff]

df_filtered <- data_clean[, c(meta_cols, genes_keep_missing)]

dim(df_filtered)

```
7. Variance filtering

After removing CpG loci with more than 25% missingness, we noticed that some of the remaining loci showed very low variability across samples. Such loci are usually uninformative for downstream analyses, so we applied a variance filter and kept only CpG loci with a standard deviation > 0.05, based on the SD histogram below.

```{r}
gene_cols_filtered <- setdiff(names(df_filtered), meta_cols)

gene_sd <- sapply(df_filtered[, gene_cols_filtered], sd, na.rm = TRUE)
df_sd <- data.frame(sd = gene_sd)

ggplot(df_sd, aes(x = sd)) +
geom_histogram(bins = 100,
    fill = "skyblue",
    color = "white"
  ) +
labs(
title = "Standard deviation of CpG loci",
x = "Standard deviation",
y = "Number of loci"
) +
theme_minimal()
```
```{r}
sd_cutoff <- 0.05
genes_keep_sd   <- names(gene_sd)[gene_sd > sd_cutoff]
genes_remove_sd <- names(gene_sd)[gene_sd <= sd_cutoff]

length(genes_keep_sd)    # how many CpG loci remain
length(genes_remove_sd)  # how many are removed

df_sd_filtered <- df_filtered[, c(meta_cols, genes_keep_sd)]

dim(df_sd_filtered)
```
This reduced the dataset to a more meaningful feature set and also made KNN imputation computationally feasible. Because R could not handle KNN imputation on the full dataset, we performed the imputation in Python

8. KNN imputation in Python (Google Colab)

At this point, the remaining missing values were imputed using KNN in Python.
We exported the filtered dataset (df_sd_filtered) as a CSV file,
performed KNN imputation in Google Colab, and then imported the imputed dataset back into R.
```{r}
write_csv(df_sd_filtered, "df_sd_filtered.csv")
```

```{python}
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd

file_path ='/content/drive/MyDrive/Colab_Notebooks/df_sd_filtered.csv'
df = pd.read_csv(file_path)

metadata_cols = ['label_title', 'label_tissue', 'label_age', 'label_gender',
                 'label_clinical stage', 'label_site label',
                 'label_source_of_sample', 'label_disease']

chrom_cols = [col for col in df.columns if col not in metadata_cols]

metadata_df = df[metadata_cols]
chrom_df = df[chrom_cols]

from sklearn.impute import KNNImputer
imputer = KNNImputer(n_neighbors=5)
chrom_imputed = imputer.fit_transform(chrom_df)

chrom_imputed_df = pd.DataFrame(chrom_imputed, columns=chrom_cols)
df_imputed = pd.concat([metadata_df.reset_index(drop=True), chrom_imputed_df], axis=1)

df_imputed.to_csv('df_imputed.csv', index=False)
```


9. Post-imputation checks in R

Finally, we checked whether:
- all dimensions were preserved
-metadata columns were unchanged
-no missing values remained in the CpG loci= correct imputation
```{r}
df_imputed <- read_csv("df_imputed.csv")

gene_cols_imputed <- setdiff(names(df_imputed), meta_cols)
genes_only <- df_imputed[, gene_cols_imputed]

#1)check for remaining NA -> must be 0

sum(is.na(genes_only))

#2)check dimensions

dim(df_imputed)

#3)check that all original columns are present-> empty vector (0)= good

setdiff(colnames(df_sd_filtered), colnames(df_imputed))
```

